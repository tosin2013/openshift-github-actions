name: Deploy HashiCorp Vault on OpenShift

# This workflow deploys HashiCorp Vault on OpenShift with HA configuration
# Based on lessons learned from deployment experiences:
# 1. Pre-creates PVCs with correct naming pattern
# 2. Creates custom SecurityContextConstraint for OpenShift
# 3. Configures Vault with Raft integrated storage
# 4. Handles initialization and unsealing process systematically
# 5. Implements secure key management practices

on:
  workflow_dispatch:
    inputs:
      namespace:
        description: 'Namespace to deploy Vault in'
        required: true
        default: 'vault'
        type: string
      storage_class:
        description: 'Storage class for Vault persistent volume'
        required: true
        type: string
      replicas:
        description: 'Number of Vault replicas'
        required: true
        default: '3'
        type: string
      ui_enabled:
        description: 'Enable Vault UI'
        required: true
        default: 'true'
        type: boolean
      auto_unseal:
        description: 'Use auto-unsealing with cloud KMS (requires additional configuration)'
        required: false
        default: false
        type: boolean
      cloud_provider:
        description: 'Cloud provider for auto-unsealing (aws, gcp, azure)'
        required: false
        default: 'none'
        type: string

jobs:
  deploy-vault:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up OpenShift CLI
        uses: redhat-actions/openshift-tools-installer@v1
        with:
          oc: '4.18'
      
      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.14.0'
      
      - name: Log in to OpenShift
        uses: redhat-actions/oc-login@v1
        with:
          openshift_server_url: ${{ secrets.OPENSHIFT_SERVER }}
          openshift_token: ${{ secrets.OPENSHIFT_TOKEN }}
          insecure_skip_tls_verify: true
      

      
      - name: Create Vault namespace
        run: |
          oc create namespace ${{ github.event.inputs.namespace }} --dry-run=client -o yaml | oc apply -f -
      
      - name: Create Vault Security Context Constraint
        run: |
          cat <<EOF | oc apply -f -
          apiVersion: security.openshift.io/v1
          kind: SecurityContextConstraints
          metadata:
            name: vault-scc
          allowHostDirVolumePlugin: false
          allowHostIPC: false # Vault may use IPC, but with mlock disabled, this might be okay. Test.
          allowHostNetwork: false
          allowHostPID: false
          allowHostPorts: false
          allowPrivilegeEscalation: true # Often needed by Vault
          allowPrivilegedContainer: false
          allowedCapabilities: # IPC_LOCK is common if mlock is not disabled. Since it is, this might be empty or minimal.
            # - IPC_LOCK # Add if testing reveals VAULT_DISABLE_MLOCK="true" is not sufficient or desired.
            - NET_BIND_SERVICE # To bind to low ports if not running as root (though Vault usually runs >1024)
          defaultAddCapabilities: null
          fsGroup:
            type: RunAsAny
          readOnlyRootFilesystem: false
          requiredDropCapabilities:
            - MKNOD # Example of a commonly dropped capability
          runAsUser:
            type: RunAsAny # Consider restricting to a specific UID range used by the Vault image/container
          seLinuxContext:
            type: MustRunAs # Or RunAsAny, consult Vault image requirements & OpenShift policy
          supplementalGroups:
            type: RunAsAny
          volumes:
            - configMap
            - downwardAPI
            - emptyDir
            - persistentVolumeClaim
            - projected
            - secret
          EOF
      
      - name: Add HashiCorp Helm repository
        run: |
          helm repo add hashicorp https://helm.releases.hashicorp.com
          helm repo update
          # Verify latest Vault chart version
          helm search repo hashicorp/vault --version "^0.30.0" -l 1
      
      - name: Create Vault ServiceAccount
        run: |
          cat <<EOF | oc apply -f -
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: vault
            namespace: ${{ github.event.inputs.namespace }}
            labels:
              app.kubernetes.io/name: vault
              app.kubernetes.io/instance: vault
          EOF
      
      - name: Create Role and RoleBinding for TokenReview
        run: |
          cat <<EOF | oc apply -f -
          apiVersion: rbac.authorization.k8s.io/v1
          kind: Role
          metadata:
            name: vault-tokenreviewer
            namespace: ${{ github.event.inputs.namespace }}
          rules:
          - apiGroups: ["authentication.k8s.io"]
            resources: ["tokenreviews"]
            verbs: ["create"]
          ---
          apiVersion: rbac.authorization.k8s.io/v1
          kind: RoleBinding
          metadata:
            name: vault-tokenreviewer-binding
            namespace: ${{ github.event.inputs.namespace }}
          roleRef:
            apiGroup: rbac.authorization.k8s.io
            kind: Role
            name: vault-tokenreviewer
          subjects:
          - kind: ServiceAccount
            name: vault
            namespace: ${{ github.event.inputs.namespace }}
          EOF
      
      - name: Bind vault-scc to vault ServiceAccount
        run: |
          oc adm policy add-scc-to-user vault-scc -z vault -n ${{ github.event.inputs.namespace }}
      
      - name: Generate TLS Certificate and Create Secret
        run: |
          NAMESPACE=${{ github.event.inputs.namespace }}
          # Attempt to discover apps domain. This is a common OpenShift pattern but might need adjustment.
          # Fallback to a placeholder if discovery fails, consider making APPS_DOMAIN an input for robustness.
          APPS_DOMAIN=$(oc get ingresses.config.openshift.io cluster -o jsonpath='{.spec.domain}' 2>/dev/null || echo "apps.cluster.example.com")
          
          echo "Generating self-signed TLS certificate for Vault..."
          echo "Using APPS_DOMAIN: $APPS_DOMAIN for one of the SANs."
          
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout vault.key -out vault.crt \
            -subj "/CN=vault.$NAMESPACE.svc/O=Vault" \
            -addext "subjectAltName = DNS:vault,DNS:vault.$NAMESPACE,DNS:vault.$NAMESPACE.svc,DNS:vault.$NAMESPACE.svc.cluster.local,DNS:localhost,DNS:vault.$APPS_DOMAIN"

          echo "Creating Kubernetes TLS secret 'vault-tls'..."
          oc create secret tls vault-tls \
            --cert=vault.crt \
            --key=vault.key \
            -n $NAMESPACE \
            --dry-run=client -o yaml | oc apply -f -
          
          echo "TLS secret 'vault-tls' created."
          # Clean up local cert files
          rm -f vault.key vault.crt
      
      - name: Create PVCs for Vault
        run: |
          echo "Creating PVCs for Vault storage..."
          
          # Get the number of replicas
          REPLICAS=${{ github.event.inputs.replicas }}
          
          # Create PVCs for each replica
          for i in $(seq 0 $(($REPLICAS - 1))); do
            cat > vault-pvc-$i.yaml <<EOF
          apiVersion: v1
          kind: PersistentVolumeClaim
          metadata:
            name: data-vault-$i
            namespace: ${{ github.event.inputs.namespace }}
            labels:
              app.kubernetes.io/name: vault
              app.kubernetes.io/instance: vault
              component: server
          spec:
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: 10Gi
            storageClassName: ${{ github.event.inputs.storage_class }}
          EOF
            
            # Apply the PVC
            oc apply -f vault-pvc-$i.yaml
            echo "Created PVC for Vault replica $i"
          done
          
          echo "All Vault PVCs created successfully"
      
      - name: Generate Vault values file
        run: |
          echo "Generating Helm values file for Vault with OpenShift-specific configurations..."
          
          # Determine if auto-unsealing should be configured
          AUTO_UNSEAL=${{ github.event.inputs.auto_unseal }}
          CLOUD_PROVIDER=${{ github.event.inputs.cloud_provider }}
          
          cat > vault-values.yaml <<EOF
          global:
            openshift: true
            enabled: true
          
          server:
            dev:
              enabled: false # Ensure dev mode is explicitly disabled for HA
            
            # Configure integrated storage (Raft)
            ha:
              enabled: true
              replicas: ${{ github.event.inputs.replicas }}
              raft:
                enabled: true
                setNodeId: true
                leaderElectionTimeout: "5s"
                leaderLeaseTimeout: "5s"
                retryJoin:
                  enabled: true
              # Inject HCL configuration for TLS listener and API/Cluster addresses
              config: |
                ui = true
                
                listener "tcp" {
                  address = "0.0.0.0:8200"
                  cluster_address = "0.0.0.0:8201"
                  tls_cert_file = "/vault/userconfig/tls/tls.crt"
                  tls_key_file  = "/vault/userconfig/tls/tls.key"
                  # Enable TLS Client CA for mTLS if needed in the future
                  # tls_client_ca_file = "/vault/userconfig/tls/client_ca.crt" 
                }

                storage "raft" {
                  path = "/vault/data"
                  node_id = "${HOSTNAME}" # Will be substituted by Vault
                }

                # Set API and Cluster addresses to use HTTPS
                api_addr = "https://0.0.0.0:8200" # Pod IP, will be NAT'd by service
                # cluster_addr will be handled by Vault/Helm chart for HA communication
            
            # Mount the TLS secret
            extraVolumes:
              - type: secret
                name: vault-tls # Name of the secret created earlier
                path: /vault/userconfig/tls # Mount path for the secret
            
            # Updated Environment variables
            extraEnvironmentVars:
              VAULT_DISABLE_CONSUL_STORAGE_MIGRATION_CHECK: "true"
              VAULT_SKIP_VERIFY: "true" # Keep for self-signed certs during internal comms if needed
              VAULT_DISABLE_MLOCK: "true"
              VAULT_LOG_LEVEL: "info"
              VAULT_ADDR: "https://localhost:8200" # For CLI use within the pod
              VAULT_API_ADDR: "https://0.0.0.0:8200" # For Vault to listen on all interfaces HTTPS
            
            readinessProbe:
              enabled: false # Keep disabled as per previous lessons
            
            securityContext:
              runAsNonRoot: true
              runAsUser: 100 # Or the UID used by the Vault image
              capabilities:
                drop:
                - ALL
            
            service:
              type: ClusterIP
            
            dataStorage:
              enabled: true
              size: 10Gi
              storageClass: ${{ github.event.inputs.storage_class }}
            
            ui:
              enabled: ${{ github.event.inputs.ui_enabled }} # This is already in ha.config, but keep for chart's top-level UI toggle
            
            # Use the manually created ServiceAccount
            serviceAccount:
              create: false # We created it manually
              name: vault # Name of the SA created earlier
              # Annotations for SCC are no longer needed here as we bind it directly
          
          injector:
            # Assuming injector also needs to use a specific SA if it's being modified,
            # but the primary focus is the Vault server SA.
            # If injector is used, its SA (vault-injector) also needs SCC binding.
            serviceAccount:
              create: true # Or false if 'vault-injector' SA is also manually created and configured
              name: vault-injector # Default name, ensure it exists or is created with proper SCC
              # annotations:
              #   "openshift.io/scc": "vault-scc" # If this SA is used and needs the same SCC
          EOF
          
          # Deploy Vault using Helm with the values file
          helm upgrade --install vault hashicorp/vault \
            --namespace ${{ github.event.inputs.namespace }} \
            --version 0.30.0 \
            --values vault-values.yaml
          
          echo "Vault deployment initiated. Waiting for pods to be created..."
          sleep 30
      
      - name: Wait for Vault pods to start
        run: |
          echo "Waiting for service accounts to be created..."
          sleep 10
          
          # Bind the SCC to Vault service accounts
          echo "Binding vault-scc to Vault service accounts..."
          oc adm policy add-scc-to-user vault-scc -z vault -n ${{ github.event.inputs.namespace }}
          oc adm policy add-scc-to-user vault-scc -z vault-agent-injector -n ${{ github.event.inputs.namespace }}
          
          # Wait for pods to be created (not ready, just running)
          echo "Waiting for Vault pods to be created..."
          # Wait for the statefulset to create the pods
          for i in {1..30}; do
            if oc get pods -l app.kubernetes.io/name=vault -n ${{ github.event.inputs.namespace }} | grep -q "vault-0"; then
              echo "Vault pods are being created..."
              break
            fi
            echo "Waiting for Vault pods to be created... ($i/30)"
            sleep 10
          done
          
          # Wait for the pods to be in Running state (they won't be Ready until initialized and unsealed)
          echo "Waiting for Vault pods to be in Running state..."
          for i in {1..30}; do
            RUNNING_COUNT=$(oc get pods -l app.kubernetes.io/name=vault -n ${{ github.event.inputs.namespace }} -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}' | wc -w)
            TOTAL_COUNT=$(oc get pods -l app.kubernetes.io/name=vault -n ${{ github.event.inputs.namespace }} --no-headers | wc -l)
            echo "Running pods: $RUNNING_COUNT/$TOTAL_COUNT"
            if [ "$RUNNING_COUNT" -eq "$TOTAL_COUNT" ] && [ "$TOTAL_COUNT" -gt 0 ]; then
              echo "All Vault pods are running."
              break
            fi
            echo "Waiting for all Vault pods to be running... ($i/30)"
            sleep 10
          done
      
      - name: Wait for Vault container to be running
        run: |
          echo "Waiting for Vault container to be running..."
          # Wait for the Vault container to be in Running state before attempting to initialize
          for i in {1..30}; do
            if oc get pod vault-0 -n ${{ github.event.inputs.namespace }} -o jsonpath='{.status.phase}' 2>/dev/null | grep -q "Running"; then
              echo "Vault pod is running."
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "Timed out waiting for Vault pod to be running."
              oc get pods -n ${{ github.event.inputs.namespace }}
              exit 1
            fi
            
            echo "Waiting for Vault pod to be running... ($i/30)"
            sleep 10
          done
          
          # Wait a bit longer to ensure the container is fully started
          echo "Waiting for Vault container to stabilize..."
          sleep 20
      
      # Wait for Vault pods to be ready before proceeding with initialization
      - name: Wait for Vault pods to be ready
        id: wait_for_vault_pods
        run: |
          NAMESPACE=${{ github.event.inputs.namespace }}
          REPLICAS=${{ github.event.inputs.replicas }}
          ./scripts/common/wait_for_vault_pods.sh "$NAMESPACE" "$REPLICAS"
      
      # Initialize and unseal Vault if auto-unseal is disabled
      - name: Initialize and Unseal Vault (if manual unseal)
        if: github.event.inputs.auto_unseal == 'false'
        id: initialize_unseal_vault
        env:
          # Pass GitHub Actions inputs and secrets to the script environment
          GITHUB_EVENT_INPUTS_NAMESPACE: ${{ github.event.inputs.namespace }}
          GITHUB_EVENT_INPUTS_REPLICAS: ${{ github.event.inputs.replicas }}
          GITHUB_EVENT_INPUTS_AUTO_UNSEAL: ${{ github.event.inputs.auto_unseal }}
          # SECRETS_VAULT_ROOT_TOKEN will be used by the script if Vault is already initialized
          SECRETS_VAULT_ROOT_TOKEN: ${{ secrets.VAULT_ROOT_TOKEN }}
          SECRETS_VAULT_UNSEAL_KEY_0: ${{ secrets.VAULT_UNSEAL_KEY_0 }}
          SECRETS_VAULT_UNSEAL_KEY_1: ${{ secrets.VAULT_UNSEAL_KEY_1 }}
          SECRETS_VAULT_UNSEAL_KEY_2: ${{ secrets.VAULT_UNSEAL_KEY_2 }}
          SECRETS_VAULT_UNSEAL_KEY_3: ${{ secrets.VAULT_UNSEAL_KEY_3 }}
          SECRETS_VAULT_UNSEAL_KEY_4: ${{ secrets.VAULT_UNSEAL_KEY_4 }}
        run: |
          echo "Executing scripts/common/initialize_unseal_vault.sh for manual initialization and unsealing..."
          chmod +x ./scripts/common/initialize_unseal_vault.sh
          ./scripts/common/initialize_unseal_vault.sh
      
      # Verify Vault status after initialization/unsealing
      - name: Verify Vault status
        id: verify_vault_status
        run: |
          NAMESPACE=${{ github.event.inputs.namespace }}
          # Use a longer timeout to ensure Vault has enough time to stabilize
          TIMEOUT=120
          echo "Verifying Vault status with a timeout of $TIMEOUT seconds..."
          
          # Check if any Vault pods are unsealed
          if oc exec -n "$NAMESPACE" vault-0 -- sh -c "VAULT_ADDR=https://localhost:8200 VAULT_SKIP_VERIFY=true vault status" 2>/dev/null | grep -q 'Sealed.*false'; then
            echo "✅ Vault is unsealed and operational"
            exit 0
          else
            echo "❌ Vault is still sealed or not responding"
            oc get pods -n "$NAMESPACE" -l app.kubernetes.io/name=vault -o wide
            exit 1
          fi
        continue-on-error: true  # Continue even if verification fails to allow for debugging
      
      # Output final status
      - name: Output Vault status
        if: always() && steps.verify_vault_status.conclusion == 'success'
        run: |
          echo "✅ Vault deployment and initialization completed successfully."
          echo "Root Token: ${{ env.VAULT_ROOT_TOKEN || 'Not available' }}"
          
          # Get the Vault UI URL if enabled
          if [ "${{ github.event.inputs.ui_enabled }}" = "true" ]; then
            VAULT_ROUTE=$(oc get route vault -n ${{ github.event.inputs.namespace }} -o jsonpath='{.spec.host}' 2>/dev/null || echo "Not available")
            echo "Vault UI: https://$VAULT_ROUTE"
          fi
      
      - name: Output Vault status (failure case)
        if: always() && steps.verify_vault_status.conclusion != 'success'
        run: |
          echo "::error::Vault verification failed. Check the logs above for details."
          echo "Root Token: ${{ env.VAULT_ROOT_TOKEN || 'Not available' }}"
          echo "\nCurrent Vault pods status:"
          oc get pods -n ${{ github.event.inputs.namespace }} -l app.kubernetes.io/name=vault -o wide
          
          # Show logs from the primary Vault pod for debugging
          echo "\n=== Vault logs (vault-0) ==="
          oc logs -n ${{ github.event.inputs.namespace }} vault-0 --tail=50 || true
          
          exit 1
      
      - name: Configure Kubernetes Auth Method in Vault
        if: steps.verify_vault_status.conclusion == 'success'
        env:
          VAULT_ROOT_TOKEN: ${{ env.VAULT_ROOT_TOKEN }}
          NAMESPACE: ${{ github.event.inputs.namespace }}
        run: |
          echo "Configuring Kubernetes authentication method in Vault..."

          echo "Retrieving token for 'vault' service account..."
          VAULT_SA_TOKEN=$(oc sa get-token vault -n "$NAMESPACE")
          if [ -z "$VAULT_SA_TOKEN" ]; then
            echo "::error::Failed to retrieve token for 'vault' service account."
            exit 1
          fi
          echo "::add-mask::$VAULT_SA_TOKEN"

          echo "Enabling Kubernetes auth method..."
          # Check if already enabled, otherwise enable it
          AUTH_LIST_OUTPUT=$(oc exec -n "$NAMESPACE" vault-0 -- /bin/sh -c \
            "VAULT_TOKEN=\"$VAULT_ROOT_TOKEN\" VAULT_ADDR=https://localhost:8200 VAULT_SKIP_VERIFY=true vault auth list -format=json")
          if echo "$AUTH_LIST_OUTPUT" | jq -e '.["kubernetes/"]' > /dev/null; then
            echo "Kubernetes auth method already enabled."
          else
            if ! oc exec -n "$NAMESPACE" vault-0 -- /bin/sh -c \
              "VAULT_TOKEN=\"$VAULT_ROOT_TOKEN\" VAULT_ADDR=https://localhost:8200 VAULT_SKIP_VERIFY=true vault auth enable kubernetes"; then
              echo "::error::Failed to enable Kubernetes auth method."
              exit 1
            else
              echo "Kubernetes auth method enabled successfully."
            fi
          fi
          
          echo "Writing Kubernetes auth config..."
          # K8S_ISSUER should align with your cluster's service account issuer
          # For OpenShift, it's typically like this, but verify for your specific version/config if issues arise.
          K8S_ISSUER="https://kubernetes.default.svc.cluster.local"

          oc exec -n "$NAMESPACE" vault-0 -- /bin/sh -c \
            "VAULT_TOKEN=\"$VAULT_ROOT_TOKEN\" VAULT_ADDR=https://localhost:8200 VAULT_SKIP_VERIFY=true vault write auth/kubernetes/config \
            token_reviewer_jwt='$VAULT_SA_TOKEN' \
            kubernetes_host='https://kubernetes.default.svc' \
            kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
            issuer='$K8S_ISSUER' \
            disable_local_ca_jwt=false"
          
          if [ $? -ne 0 ]; then
            echo "::error::Failed to write Kubernetes auth config to Vault."
            echo "::group::vault-0 logs on K8s auth config failure"
            oc logs -n "$NAMESPACE" vault-0 --tail=50 || echo "Failed to get vault-0 logs."
            echo "::endgroup::"
            exit 1
          fi

          echo "Creating example Kubernetes auth role 'my-app-role'..."
          oc exec -n "$NAMESPACE" vault-0 -- /bin/sh -c \
            "VAULT_TOKEN=\"$VAULT_ROOT_TOKEN\" VAULT_ADDR=https://localhost:8200 VAULT_SKIP_VERIFY=true vault write auth/kubernetes/role/my-app-role \
            bound_service_account_names=my-app-sa \
            bound_service_account_namespaces='$NAMESPACE' \
            policies=default,my-app-policy \
            ttl=24h"
          
          if [ $? -ne 0 ]; then
            echo "::error::Failed to create 'my-app-role' in Vault."
            echo "::group::vault-0 logs on K8s role creation failure"
            oc logs -n "$NAMESPACE" vault-0 --tail=50 || echo "Failed to get vault-0 logs."
            echo "::endgroup::"
            # Consider not exiting fatally here if an example role failing is not critical
            # exit 1 
            echo "::warning::Failed to create example 'my-app-role'. This might not be critical."
          fi

          echo "Kubernetes auth method configuration attempt completed."
      
      - name: Create Route for Vault UI
        if: ${{ github.event.inputs.ui_enabled == 'true' }}
        run: |
          cat <<EOF | oc apply -f -
          apiVersion: route.openshift.io/v1
          kind: Route
          metadata:
            name: vault
            namespace: ${{ github.event.inputs.namespace }}
          spec:
            port:
              targetPort: 8200
            tls:
              termination: passthrough
            to:
              kind: Service
              name: vault
              weight: 100
          EOF
          
          VAULT_ROUTE=$(oc get route vault -n ${{ github.event.inputs.namespace }} -o jsonpath='{.spec.host}')
          echo "Vault UI is accessible at: https://$VAULT_ROUTE"
          echo "VAULT_ROUTE=$VAULT_ROUTE" >> $GITHUB_ENV
      
      - name: Output Vault Information
        run: |
          echo "Vault has been successfully deployed to OpenShift"
          echo "Namespace: ${{ github.event.inputs.namespace }}"
          if [[ "${{ github.event.inputs.ui_enabled }}" == "true" ]]; then
            echo "Vault UI URL: https://${{ env.VAULT_ROUTE }}"
          fi
          echo "To use Vault, you'll need the root token and unseal keys that were generated"
          echo "These have been stored as outputs of this workflow run"
          
          # Instructions for configuring GitHub repository
          echo "To configure your GitHub repository to use this Vault instance:"
          echo "1. Create GitHub repository secrets for VAULT_ADDR and VAULT_ROLE"
          echo "2. Update your GitHub Actions workflows to authenticate with this Vault instance"
