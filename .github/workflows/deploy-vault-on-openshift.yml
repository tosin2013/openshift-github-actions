name: Deploy HashiCorp Vault on OpenShift

# This workflow deploys HashiCorp Vault on OpenShift with HA configuration
# Based on lessons learned from deployment experiences:
# 1. Pre-creates PVCs with correct naming pattern
# 2. Creates custom SecurityContextConstraint for OpenShift
# 3. Configures Vault with Raft integrated storage
# 4. Handles initialization and unsealing process systematically
# 5. Implements secure key management practices

on:
  workflow_dispatch:
    inputs:
      namespace:
        description: 'Namespace to deploy Vault in'
        required: true
        default: 'vault'
        type: string
      storage_class:
        description: 'Storage class for Vault persistent volume'
        required: true
        type: string
      replicas:
        description: 'Number of Vault replicas'
        required: true
        default: '3'
        type: string
      ui_enabled:
        description: 'Enable Vault UI'
        required: true
        default: 'true'
        type: boolean
      auto_unseal:
        description: 'Use auto-unsealing with cloud KMS (requires additional configuration)'
        required: false
        default: false
        type: boolean
      cloud_provider:
        description: 'Cloud provider for auto-unsealing (aws, gcp, azure)'
        required: false
        default: 'none'
        type: string

jobs:
  deploy-vault:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up OpenShift CLI
        uses: redhat-actions/openshift-tools-installer@v1
        with:
          oc: '4.18'
      
      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.14.0'
      
      - name: Log in to OpenShift
        uses: redhat-actions/oc-login@v1
        with:
          openshift_server_url: ${{ secrets.OPENSHIFT_SERVER }}
          openshift_token: ${{ secrets.OPENSHIFT_TOKEN }}
          insecure_skip_tls_verify: true
      

      
      - name: Create Vault namespace
        run: |
          oc create namespace ${{ github.event.inputs.namespace }} --dry-run=client -o yaml | oc apply -f -
      
      - name: Create Vault Security Context Constraint
        run: |
          cat <<EOF | oc apply -f -
          apiVersion: security.openshift.io/v1
          kind: SecurityContextConstraints
          metadata:
            name: vault-scc
          allowHostDirVolumePlugin: false
          allowHostIPC: false
          allowHostNetwork: false
          allowHostPID: false
          allowHostPorts: false
          allowPrivilegeEscalation: true
          allowPrivilegedContainer: false
          allowedCapabilities: null
          defaultAddCapabilities: null
          fsGroup:
            type: RunAsAny
          groups: []
          priority: 10
          readOnlyRootFilesystem: false
          requiredDropCapabilities:
          - ALL
          runAsUser:
            type: RunAsAny
          seLinuxContext:
            type: MustRunAs
          supplementalGroups:
            type: RunAsAny
          users: []
          volumes:
          - configMap
          - downwardAPI
          - emptyDir
          - persistentVolumeClaim
          - projected
          - secret
          EOF
      
      - name: Add HashiCorp Helm repository
        run: |
          helm repo add hashicorp https://helm.releases.hashicorp.com
          helm repo update
          # Verify latest Vault chart version
          helm search repo hashicorp/vault --version "^0.30.0" -l 1
      
      - name: Create PVCs for Vault
        run: |
          echo "Creating PVCs for Vault storage..."
          
          # Get the number of replicas
          REPLICAS=${{ github.event.inputs.replicas }}
          
          # Create PVCs for each replica
          for i in $(seq 0 $(($REPLICAS - 1))); do
            cat > vault-pvc-$i.yaml <<EOF
          apiVersion: v1
          kind: PersistentVolumeClaim
          metadata:
            name: data-vault-$i
            namespace: ${{ github.event.inputs.namespace }}
            labels:
              app.kubernetes.io/name: vault
              app.kubernetes.io/instance: vault
              component: server
          spec:
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: 10Gi
            storageClassName: ${{ github.event.inputs.storage_class }}
          EOF
            
            # Apply the PVC
            oc apply -f vault-pvc-$i.yaml
            echo "Created PVC for Vault replica $i"
          done
          
          echo "All Vault PVCs created successfully"
      
      - name: Generate Vault values file
        run: |
          echo "Generating Helm values file for Vault with OpenShift-specific configurations..."
          
          # Determine if auto-unsealing should be configured
          AUTO_UNSEAL=${{ github.event.inputs.auto_unseal }}
          CLOUD_PROVIDER=${{ github.event.inputs.cloud_provider }}
          
          cat > vault-values.yaml <<EOF
          global:
            openshift: true
            enabled: true
          
          server:
            dev:
              enabled: false
            
            # Configure integrated storage (Raft) based on retrospective lessons
            ha:
              enabled: true
              replicas: ${{ github.event.inputs.replicas }}
              raft:
                enabled: true
                setNodeId: true
                # Ensure proper leader election in HA mode
                leaderElectionTimeout: "5s"
                leaderLeaseTimeout: "5s"
                retryJoin:
                  enabled: true
            
            # Environment variables based on retrospective lessons
            extraEnvironmentVars:
              # Critical for OpenShift deployment
              VAULT_DISABLE_CONSUL_STORAGE_MIGRATION_CHECK: "true"
              VAULT_SKIP_VERIFY: "true"
              VAULT_DISABLE_MLOCK: "true"
              # Improve logging for troubleshooting
              VAULT_LOG_LEVEL: "info"
            
            # Disable readiness probe to allow pods to start without being ready
            # Lesson learned: Default probe is too strict for OpenShift environments
            readinessProbe:
              enabled: false
            
            # Configure security context for OpenShift compatibility
            # Lesson learned: OpenShift has strict security requirements
            securityContext:
              runAsNonRoot: true
              runAsUser: 100
              capabilities:
                drop:
                - ALL
            
            service:
              type: ClusterIP
            
            # Configure storage to use pre-created PVCs
            # Lesson learned: Pre-creating PVCs ensures proper storage configuration
            dataStorage:
              enabled: true
              size: 10Gi
              storageClass: ${{ github.event.inputs.storage_class }}
              existingClaim: "data-vault-"
            
            ui:
              enabled: ${{ github.event.inputs.ui_enabled }}
            
            # Ensure service account has proper permissions for OpenShift
            serviceAccount:
              create: true
              annotations:
                # Explicitly annotate for OpenShift security context constraints
                "openshift.io/scc": "vault-scc"
          
          injector:
            serviceAccount:
              create: true
              name: vault-injector
              annotations:
                "openshift.io/scc": "vault-scc"
          EOF
          
          # Deploy Vault using Helm with the values file
          helm upgrade --install vault hashicorp/vault \
            --namespace ${{ github.event.inputs.namespace }} \
            --version 0.30.0 \
            --values vault-values.yaml
          
          echo "Vault deployment initiated. Waiting for pods to be created..."
          sleep 30
      
      - name: Wait for Vault pods to start
        run: |
          echo "Waiting for service accounts to be created..."
          sleep 10
          
          # Bind the SCC to Vault service accounts
          echo "Binding vault-scc to Vault service accounts..."
          oc adm policy add-scc-to-user vault-scc -z vault -n ${{ github.event.inputs.namespace }}
          oc adm policy add-scc-to-user vault-scc -z vault-agent-injector -n ${{ github.event.inputs.namespace }}
          
          # Wait for pods to be created (not ready, just running)
          echo "Waiting for Vault pods to be created..."
          # Wait for the statefulset to create the pods
          for i in {1..30}; do
            if oc get pods -l app.kubernetes.io/name=vault -n ${{ github.event.inputs.namespace }} | grep -q "vault-0"; then
              echo "Vault pods are being created..."
              break
            fi
            echo "Waiting for Vault pods to be created... ($i/30)"
            sleep 10
          done
          
          # Wait for the pods to be in Running state (they won't be Ready until initialized and unsealed)
          echo "Waiting for Vault pods to be in Running state..."
          for i in {1..30}; do
            RUNNING_COUNT=$(oc get pods -l app.kubernetes.io/name=vault -n ${{ github.event.inputs.namespace }} -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}' | wc -w)
            TOTAL_COUNT=$(oc get pods -l app.kubernetes.io/name=vault -n ${{ github.event.inputs.namespace }} --no-headers | wc -l)
            echo "Running pods: $RUNNING_COUNT/$TOTAL_COUNT"
            if [ "$RUNNING_COUNT" -eq "$TOTAL_COUNT" ] && [ "$TOTAL_COUNT" -gt 0 ]; then
              echo "All Vault pods are running."
              break
            fi
            echo "Waiting for all Vault pods to be running... ($i/30)"
            sleep 10
          done
      
      - name: Wait for Vault container to be running
        run: |
          echo "Waiting for Vault container to be running..."
          # Wait for the Vault container to be in Running state before attempting to initialize
          for i in {1..30}; do
            if oc get pod vault-0 -n ${{ github.event.inputs.namespace }} -o jsonpath='{.status.phase}' 2>/dev/null | grep -q "Running"; then
              echo "Vault pod is running."
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "Timed out waiting for Vault pod to be running."
              oc get pods -n ${{ github.event.inputs.namespace }}
              exit 1
            fi
            
            echo "Waiting for Vault pod to be running... ($i/30)"
            sleep 10
          done
          
          # Wait a bit longer to ensure the container is fully started
          echo "Waiting for Vault container to stabilize..."
          sleep 20
      
      - name: Initialize and Unseal Vault (Manual or Verify Auto-Unseal)
        id: init_unseal
        # This step handles manual initialization and unsealing if auto-unseal is disabled.
        # If auto-unseal is enabled, it primarily verifies the unseal status.
        run: |
          set -e # Exit immediately if a command exits with a non-zero status.
          echo "Starting Vault Initialization and Unsealing Process..."
          REPLICAS=${{ github.event.inputs.replicas }}
          NAMESPACE=${{ github.event.inputs.namespace }}

          # Wait for all Vault pods to be in Running state before proceeding
          echo "Ensuring all Vault pods are in Running state..."
          for i in {1..30}; do
            RUNNING_PODS=$(oc get pods -l app.kubernetes.io/name=vault -n $NAMESPACE -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}' | wc -w | tr -d ' ')
            TOTAL_PODS=$(oc get pods -l app.kubernetes.io/name=vault -n $NAMESPACE --no-headers | wc -l | tr -d ' ')
            
            echo "Running pods: $RUNNING_PODS/$TOTAL_PODS (Expected: $REPLICAS)"
            # Ensure we have at least the expected number of replicas running
            if [ "$RUNNING_PODS" -eq "$TOTAL_PODS" ] && [ "$TOTAL_PODS" -ge "$REPLICAS" ] && [ "$TOTAL_PODS" -gt 0 ]; then
              echo "All $TOTAL_PODS Vault pods are running."
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "::error::Timed out waiting for all Vault pods to be running."
              oc get pods -n $NAMESPACE -l app.kubernetes.io/name=vault
              exit 1
            fi
            echo "Waiting for all Vault pods to be running... (Attempt $i/30)"
            sleep 10
          done

          if [ "${{ github.event.inputs.auto_unseal }}" == "false" ]; then
            echo "Manual unsealing process initiated..."

            # Step 1: Initialize only the first Vault pod (vault-0) if not already initialized
            echo "Checking initialization status of vault-0..."
            # Ensure VAULT_SKIP_VERIFY is respected if communication is over TLS internally, though localhost is http
            INIT_STATUS_JSON=$(oc exec -n $NAMESPACE vault-0 -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_SKIP_VERIFY=true vault status -format=json" 2>/dev/null || echo '{"initialized":false}')
            IS_INITIALIZED=$(echo "$INIT_STATUS_JSON" | jq -r '.initialized')

            if [ "$IS_INITIALIZED" == "true" ]; then
              echo "Vault is already initialized."
              echo "::warning::Vault already initialized. For manual unsealing of other pods, VAULT_ROOT_TOKEN and VAULT_UNSEAL_KEYs must be available as GitHub secrets (e.g., secrets.VAULT_UNSEAL_KEY_0)."
              
              if [ -z "${{ secrets.VAULT_UNSEAL_KEY_0 }}" ]; then
                  echo "::error::Vault is pre-initialized but VAULT_UNSEAL_KEY_0 secret is not provided. Cannot proceed with manual unsealing of other pods if they are sealed."
                  # Set placeholders, but expect unsealing to fail for other pods if they are sealed
                  echo "VAULT_ROOT_TOKEN=s.unknownPreInitialized" >> $GITHUB_ENV
                  for j in {0..4}; do echo "VAULT_UNSEAL_KEY_$j=unknownPreInitializedKey$j" >> $GITHUB_ENV; done
              else
                  echo "Using VAULT_ROOT_TOKEN and VAULT_UNSEAL_KEYs from GitHub secrets for potentially sealed pods."
                  echo "VAULT_ROOT_TOKEN=${{ secrets.VAULT_ROOT_TOKEN }}" >> $GITHUB_ENV
                  echo "VAULT_UNSEAL_KEY_0=${{ secrets.VAULT_UNSEAL_KEY_0 }}" >> $GITHUB_ENV
                  echo "VAULT_UNSEAL_KEY_1=${{ secrets.VAULT_UNSEAL_KEY_1 }}" >> $GITHUB_ENV
                  echo "VAULT_UNSEAL_KEY_2=${{ secrets.VAULT_UNSEAL_KEY_2 }}" >> $GITHUB_ENV
                  # Add more keys if using more than 3 for unseal, matching the original init or secret setup
                  # For example, if 5 keys were generated, ensure secrets for VAULT_UNSEAL_KEY_3 and VAULT_UNSEAL_KEY_4 are also available.
                  [ ! -z "${{ secrets.VAULT_UNSEAL_KEY_3 }}" ] && echo "VAULT_UNSEAL_KEY_3=${{ secrets.VAULT_UNSEAL_KEY_3 }}" >> $GITHUB_ENV
                  [ ! -z "${{ secrets.VAULT_UNSEAL_KEY_4 }}" ] && echo "VAULT_UNSEAL_KEY_4=${{ secrets.VAULT_UNSEAL_KEY_4 }}" >> $GITHUB_ENV
              fi
            else
              echo "Initializing Vault on vault-0 (5 keys, 3 threshold)..."
              INIT_OUTPUT=$(oc exec -n $NAMESPACE vault-0 -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_SKIP_VERIFY=true vault operator init -key-shares=5 -key-threshold=3 -format=json")
              if [ $? -ne 0 ]; then
                echo "::error::Vault initialization failed on vault-0."
                exit 1
              fi
              echo "Vault initialized successfully on vault-0."

              ROOT_TOKEN=$(echo "$INIT_OUTPUT" | jq -r '.root_token')
              echo "::add-mask::$ROOT_TOKEN"
              echo "VAULT_ROOT_TOKEN=$ROOT_TOKEN" >> $GITHUB_ENV
              echo "Root token stored in GITHUB_ENV."

              echo "Storing unseal keys in GITHUB_ENV..."
              for j in {0..4}; do # 5 keys were generated
                KEY=$(echo "$INIT_OUTPUT" | jq -r ".unseal_keys_b64[$j]")
                echo "::add-mask::$KEY"
                echo "VAULT_UNSEAL_KEY_$j=$KEY" >> $GITHUB_ENV
              done
              echo "Unseal keys stored in GITHUB_ENV."
            fi

            # Step 2: Unseal all Vault pods (if manual unsealing)
            # Readiness probe is disabled via Helm values, so no need to patch StatefulSet here.
            echo "Proceeding to unseal all Vault pods manually..."
            for pod_name in $(oc get pods -l app.kubernetes.io/name=vault -n $NAMESPACE -o jsonpath='{.items[*].metadata.name}'); do
              echo "Processing pod $pod_name for unsealing..."
              SEAL_STATUS_JSON=$(oc exec -n $NAMESPACE $pod_name -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_SKIP_VERIFY=true vault status -format=json" 2>/dev/null || echo '{"sealed":true}')
              IS_SEALED=$(echo "$SEAL_STATUS_JSON" | jq -r '.sealed')

              if [ "$IS_SEALED" != "true" ]; then
                echo "Vault pod $pod_name is already unsealed."
                continue
              fi

              echo "Attempting to unseal pod $pod_name..."
              # Unseal with the first 3 keys (threshold is 3)
              KEY_0_FROM_ENV="${{ env.VAULT_UNSEAL_KEY_0 }}"
              KEY_1_FROM_ENV="${{ env.VAULT_UNSEAL_KEY_1 }}"
              KEY_2_FROM_ENV="${{ env.VAULT_UNSEAL_KEY_2 }}"

              if [ -z "$KEY_0_FROM_ENV" ] || [ "$KEY_0_FROM_ENV" == "unknownPreInitializedKey0" ] || [ -z "$KEY_1_FROM_ENV" ] || [ -z "$KEY_2_FROM_ENV" ]; then
                 echo "::error::Unseal keys are not properly set in GITHUB_ENV (VAULT_UNSEAL_KEY_0/1/2). Cannot unseal $pod_name. Check secrets or init output."
                 continue # Skip this pod, final verification will fail
              fi
              
              UNSEAL_SUCCESS=false
              for attempt in {1..3}; do # Retry unseal attempts
                echo "Unseal attempt $attempt for $pod_name..."
                oc exec -n $NAMESPACE $pod_name -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_SKIP_VERIFY=true vault operator unseal $KEY_0_FROM_ENV" || echo "Warning: Command to apply key 0 failed for $pod_name attempt $attempt"
                sleep 1
                oc exec -n $NAMESPACE $pod_name -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_SKIP_VERIFY=true vault operator unseal $KEY_1_FROM_ENV" || echo "Warning: Command to apply key 1 failed for $pod_name attempt $attempt"
                sleep 1
                oc exec -n $NAMESPACE $pod_name -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_SKIP_VERIFY=true vault operator unseal $KEY_2_FROM_ENV" || echo "Warning: Command to apply key 2 failed for $pod_name attempt $attempt"
                sleep 2

                CURRENT_SEAL_STATUS_JSON=$(oc exec -n $NAMESPACE $pod_name -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_SKIP_VERIFY=true vault status -format=json" 2>/dev/null || echo '{"sealed":true}')
                CURRENT_IS_SEALED=$(echo "$CURRENT_SEAL_STATUS_JSON" | jq -r '.sealed')

                if [ "$CURRENT_IS_SEALED" != "true" ]; then
                  echo "Successfully unsealed pod $pod_name."
                  UNSEAL_SUCCESS=true
                  break
                fi
                echo "Warning: Failed to unseal pod $pod_name on attempt $attempt. Retrying if attempts remain..."
                sleep 3
              done

              if [ "$UNSEAL_SUCCESS" == "false" ]; then
                echo "::error::Failed to unseal pod $pod_name after multiple attempts."
              fi
            done
            echo "Manual unsealing process completed for all pods."

          else # Auto-unseal is true
            echo "Auto-unsealing is enabled via github.event.inputs.auto_unseal = true."
            echo "Skipping manual initialization and unsealing steps. Relying on cloud KMS."
            echo "Waiting 60 seconds to allow auto-unseal to complete and cluster to stabilize..."
            sleep 60
          fi

          # Step 3: Final Verification of all pods' status
          echo "Verifying unseal and initialization status of all Vault pods..."
          ALL_OPERATIONAL=true
          for pod_name in $(oc get pods -l app.kubernetes.io/name=vault -n $NAMESPACE -o jsonpath='{.items[*].metadata.name}'); do
            echo "Verifying status of $pod_name..."
            # Use a more resilient check for status, ensuring command succeeds before parsing JSON
            STATUS_CMD_OUTPUT=$(oc exec -n $NAMESPACE $pod_name -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_SKIP_VERIFY=true vault status -format=json")
            if [ $? -ne 0 ]; then
                echo "::error::Failed to get status from pod $pod_name. It might not be fully operational or accessible."
                ALL_OPERATIONAL=false
                continue
            fi
            FINAL_IS_INITIALIZED=$(echo "$STATUS_CMD_OUTPUT" | jq -r '.initialized')
            FINAL_IS_SEALED=$(echo "$STATUS_CMD_OUTPUT" | jq -r '.sealed')

            if [ "$FINAL_IS_INITIALIZED" != "true" ]; then
                echo "::error::Pod $pod_name is NOT INITIALIZED!"
                ALL_OPERATIONAL=false
            elif [ "$FINAL_IS_SEALED" == "true" ]; then
                echo "::error::Pod $pod_name is INITIALIZED but still SEALED!"
                ALL_OPERATIONAL=false
            else
                echo "Pod $pod_name is initialized and unsealed."
            fi
          done

          if [ "$ALL_OPERATIONAL" == "true" ]; then
            echo "All Vault pods are confirmed initialized and unsealed successfully."
            echo "all_pods_unsealed=true" >> "$GITHUB_OUTPUT"
          else
            echo "::error::One or more Vault pods are not correctly initialized or unsealed. Please check logs above."
            echo "Dumping current pod statuses and recent logs for debugging..."
            oc get pods -n $NAMESPACE -l app.kubernetes.io/name=vault -o wide
            for pod_name_logs in $(oc get pods -l app.kubernetes.io/name=vault -n $NAMESPACE -o jsonpath='{.items[*].metadata.name}'); do
              echo "---- Logs for $pod_name_logs ----"
              oc logs --tail=50 $pod_name_logs -n $NAMESPACE -c vault || echo "Could not retrieve logs for container 'vault' in $pod_name_logs"
            done
            exit 1 # Critical failure
          fi
          
          # Output the root token if it was generated/used during manual unseal
          if [ "${{ github.event.inputs.auto_unseal }}" == "false" ]; then
            # Ensure VAULT_ROOT_TOKEN is available from GITHUB_ENV
            echo "vault_root_token=${{ env.VAULT_ROOT_TOKEN }}" >> "$GITHUB_OUTPUT"
            echo "::set-output name=vault_root_token_step_output::${{ env.VAULT_ROOT_TOKEN }}" # Legacy set-output for potential compatibility
            echo "Vault Root Token (from manual process) made available as step output."
          fi
          echo "Vault initialization and unsealing verification step completed."
      
      - name: Configure Vault for OpenShift Authentication
        run: |
          echo "Configuring Vault for OpenShift Authentication..."
          
          # Configure Vault with error handling and retries
          for i in {1..5}; do
            echo "Attempt $i to configure Vault..."
            
            # Configure Vault with proper error handling
            if oc exec -n ${{ github.event.inputs.namespace }} vault-0 -- sh -c "export VAULT_ADDR='https://127.0.0.1:8200' && export VAULT_SKIP_VERIFY=true && export VAULT_TOKEN='${{ env.VAULT_ROOT_TOKEN }}' && \
              # Enable required secret engines
              vault secrets enable -path=secret kv-v2 2>/dev/null || echo 'Secret engine may already be enabled' && \
              vault secrets enable aws 2>/dev/null || echo 'AWS engine may already be enabled' && \
              vault secrets enable azure 2>/dev/null || echo 'Azure engine may already be enabled' && \
              vault secrets enable gcp 2>/dev/null || echo 'GCP engine may already be enabled' && \
              
              # Enable JWT auth for GitHub Actions
              vault auth enable jwt 2>/dev/null || echo 'JWT auth may already be enabled' && \
              
              # Configure JWT auth for GitHub Actions
              vault write auth/jwt/config \
                bound_issuer='https://token.actions.githubusercontent.com' \
                oidc_discovery_url='https://token.actions.githubusercontent.com' && \
              
              # Create policy for OpenShift deployments
              vault policy write openshift-deployment - <<EOF
              # Read OpenShift secrets
              path \"secret/data/openshift/*\" {
                capabilities = [\"read\"]
              }
              
              # Read AWS dynamic credentials
              path \"aws/creds/openshift-installer\" {
                capabilities = [\"read\"]
              }
              
              # Read Azure dynamic credentials
              path \"azure/creds/openshift-installer\" {
                capabilities = [\"read\"]
              }
              
              # Read GCP dynamic credentials
              path \"gcp/key/openshift-installer\" {
                capabilities = [\"read\"]
              }
              
              # Write cluster metadata
              path \"secret/data/openshift/clusters/*\" {
                capabilities = [\"create\", \"update\", \"read\"]
              }
              EOF
            "; then
              echo "Vault configuration completed successfully."
              break
            else
              echo "Vault configuration attempt $i failed. Retrying in 10 seconds..."
              if [ $i -eq 5 ]; then
                echo "Failed to configure Vault after 5 attempts. Check Vault status and logs."
                oc get pods -n ${{ github.event.inputs.namespace }}
                oc logs -l app.kubernetes.io/name=vault -n ${{ github.event.inputs.namespace }} --tail=50
                echo "Continuing anyway, as basic Vault functionality may still work."
              else
                sleep 10
              fi
            fi
          done
      
      - name: Create Route for Vault UI
        if: ${{ github.event.inputs.ui_enabled == 'true' }}
        run: |
          cat <<EOF | oc apply -f -
          apiVersion: route.openshift.io/v1
          kind: Route
          metadata:
            name: vault
            namespace: ${{ github.event.inputs.namespace }}
          spec:
            port:
              targetPort: 8200
            tls:
              termination: passthrough
            to:
              kind: Service
              name: vault
              weight: 100
          EOF
          
          VAULT_ROUTE=$(oc get route vault -n ${{ github.event.inputs.namespace }} -o jsonpath='{.spec.host}')
          echo "Vault UI is accessible at: https://$VAULT_ROUTE"
          echo "VAULT_ROUTE=$VAULT_ROUTE" >> $GITHUB_ENV
      
      - name: Output Vault Information
        run: |
          echo "Vault has been successfully deployed to OpenShift"
          echo "Namespace: ${{ github.event.inputs.namespace }}"
          if [[ "${{ github.event.inputs.ui_enabled }}" == "true" ]]; then
            echo "Vault UI URL: https://${{ env.VAULT_ROUTE }}"
          fi
          echo "To use Vault, you'll need the root token and unseal keys that were generated"
          echo "These have been stored as outputs of this workflow run"
          
          # Instructions for configuring GitHub repository
          echo "To configure your GitHub repository to use this Vault instance:"
          echo "1. Create GitHub repository secrets for VAULT_ADDR and VAULT_ROLE"
          echo "2. Update your GitHub Actions workflows to authenticate with this Vault instance"
