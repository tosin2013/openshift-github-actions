name: Deploy HashiCorp Vault on OpenShift

on:
  workflow_dispatch:
    inputs:
      namespace:
        description: 'Namespace to deploy Vault in'
        required: true
        default: 'vault'
        type: string
      storage_class:
        description: 'Storage class for Vault persistent volume'
        required: true
        type: string
      replicas:
        description: 'Number of Vault replicas'
        required: true
        default: '3'
        type: string
      ui_enabled:
        description: 'Enable Vault UI'
        required: true
        default: 'true'
        type: boolean

jobs:
  deploy-vault:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up OpenShift CLI
        uses: redhat-actions/openshift-tools-installer@v1
        with:
          oc: '4.18'
      
      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.14.0'
      
      - name: Log in to OpenShift
        uses: redhat-actions/oc-login@v1
        with:
          openshift_server_url: ${{ secrets.OPENSHIFT_SERVER }}
          openshift_token: ${{ secrets.OPENSHIFT_TOKEN }}
          insecure_skip_tls_verify: true
      
      - name: Create Vault namespace
        run: |
          oc create namespace ${{ github.event.inputs.namespace }} --dry-run=client -o yaml | oc apply -f -
      
      - name: Create Vault Security Context Constraint
        run: |
          cat <<EOF | oc apply -f -
          apiVersion: security.openshift.io/v1
          kind: SecurityContextConstraints
          metadata:
            name: vault-scc
          allowHostDirVolumePlugin: false
          allowHostIPC: false
          allowHostNetwork: false
          allowHostPID: false
          allowHostPorts: false
          allowPrivilegeEscalation: true
          allowPrivilegedContainer: false
          allowedCapabilities: null
          defaultAddCapabilities: null
          fsGroup:
            type: RunAsAny
          groups: []
          priority: 10
          readOnlyRootFilesystem: false
          requiredDropCapabilities:
          - ALL
          runAsUser:
            type: RunAsAny
          seLinuxContext:
            type: MustRunAs
          supplementalGroups:
            type: RunAsAny
          users: []
          volumes:
          - configMap
          - downwardAPI
          - emptyDir
          - persistentVolumeClaim
          - projected
          - secret
          EOF
      
      - name: Add HashiCorp Helm repository
        run: |
          helm repo add hashicorp https://helm.releases.hashicorp.com
          helm repo update
          # Verify latest Vault chart version
          helm search repo hashicorp/vault --version "^0.30.0" -l 1
      
      - name: Generate Vault values file
        run: |
          cat > vault-values.yaml <<EOF
          global:
            openshift: true
            
          server:
            dev:
              enabled: false
            ha:
              enabled: true
              replicas: ${{ github.event.inputs.replicas }}
            service:
              type: ClusterIP
            dataStorage:
              enabled: true
              size: 10Gi
              storageClass: ${{ github.event.inputs.storage_class }}
            ui:
              enabled: ${{ github.event.inputs.ui_enabled }}
              # Ensure service account has proper permissions for OpenShift
              serviceAccount:
                create: true
                annotations:
                  serviceaccounts.openshift.io/oauth-redirectreference.primary: '{"kind":"OAuthRedirectReference","apiVersion":"v1","reference":{"kind":"Route","name":"vault"}}'
          injector:
            enabled: true
          EOF
      
      - name: Deploy Vault with Helm
        run: |
          helm install vault hashicorp/vault \
            --version 0.30.0 \
            --namespace ${{ github.event.inputs.namespace }} \
            -f vault-values.yaml
      
      - name: Wait for Vault pods to start
        run: |
          echo "Waiting for service accounts to be created..."
          sleep 10
          
          # Bind the SCC to Vault service accounts
          echo "Binding vault-scc to Vault service accounts..."
          oc adm policy add-scc-to-user vault-scc -z vault -n ${{ github.event.inputs.namespace }}
          oc adm policy add-scc-to-user vault-scc -z vault-agent-injector -n ${{ github.event.inputs.namespace }}
          
          # Wait for pods to be created (not ready, just running)
          echo "Waiting for Vault pods to be created..."
          # Wait for the statefulset to create the pods
          for i in {1..30}; do
            if oc get pods -l app.kubernetes.io/name=vault -n ${{ github.event.inputs.namespace }} | grep -q "vault-0"; then
              echo "Vault pods are being created..."
              break
            fi
            echo "Waiting for Vault pods to be created... ($i/30)"
            sleep 10
          done
          
          # Wait for the pods to be in Running state (they won't be Ready until initialized and unsealed)
          echo "Waiting for Vault pods to be in Running state..."
          for i in {1..30}; do
            RUNNING_COUNT=$(oc get pods -l app.kubernetes.io/name=vault -n ${{ github.event.inputs.namespace }} -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}' | wc -w)
            TOTAL_COUNT=$(oc get pods -l app.kubernetes.io/name=vault -n ${{ github.event.inputs.namespace }} --no-headers | wc -l)
            echo "Running pods: $RUNNING_COUNT/$TOTAL_COUNT"
            if [ "$RUNNING_COUNT" -eq "$TOTAL_COUNT" ] && [ "$TOTAL_COUNT" -gt 0 ]; then
              echo "All Vault pods are running."
              break
            fi
            echo "Waiting for all Vault pods to be running... ($i/30)"
            sleep 10
          done
      
      - name: Wait for Vault container to be running
        run: |
          echo "Waiting for Vault container to be running..."
          # Wait for the Vault container to be in Running state before attempting to initialize
          for i in {1..30}; do
            if oc get pod vault-0 -n ${{ github.event.inputs.namespace }} -o jsonpath='{.status.phase}' 2>/dev/null | grep -q "Running"; then
              echo "Vault pod is running."
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "Timed out waiting for Vault pod to be running."
              oc get pods -n ${{ github.event.inputs.namespace }}
              exit 1
            fi
            
            echo "Waiting for Vault pod to be running... ($i/30)"
            sleep 10
          done
          
          # Wait a bit longer to ensure the container is fully started
          echo "Waiting for Vault container to stabilize..."
          sleep 20
      
      - name: Initialize Vault
        id: init
        run: |
          echo "Initializing Vault..."
          
          # Create a temporary initialization script
          cat > init-vault.sh <<EOF
          #!/bin/bash
          set -e
          
          # Check if Vault is already initialized by looking at the file system
          # This avoids connecting to the API which might not be ready
          if [ -f /vault/data/.vault-initialized ]; then
            echo "Vault is already initialized according to filesystem marker."
            exit 0
          fi
          
          # Try to initialize Vault
          echo "Attempting to initialize Vault..."
          INIT_OUTPUT=\$(vault operator init -format=json 2>/dev/null || echo '{}')
          
          # Check if initialization was successful by looking for root_token
          if [ -n "\$(echo \$INIT_OUTPUT | jq -r '.root_token // empty')" ]; then
            echo "\$INIT_OUTPUT" > /vault/data/init-output.json
            touch /vault/data/.vault-initialized
            echo "Vault initialized successfully."
            exit 0
          else
            echo "Failed to initialize Vault or already initialized."
            exit 1
          fi
          EOF
          
          # Make the script executable
          chmod +x init-vault.sh
          
          # Copy the script to the pod
          oc cp init-vault.sh ${{ github.event.inputs.namespace }}/vault-0:/tmp/init-vault.sh
          
          # Run the initialization script with retries
          for i in {1..10}; do
            echo "Attempt $i to initialize Vault..."
            if oc exec -n ${{ github.event.inputs.namespace }} vault-0 -- sh -c "export VAULT_ADDR='http://127.0.0.1:8200' && /tmp/init-vault.sh"; then
              echo "Initialization script completed successfully."
              break
            fi
            
            if [ $i -eq 10 ]; then
              echo "Failed to initialize Vault after 10 attempts."
              oc logs -n ${{ github.event.inputs.namespace }} vault-0
              exit 1
            fi
            
            echo "Waiting before retry..."
            sleep 15
          done
          
          # Retrieve the initialization output
          echo "Retrieving initialization data..."
          INIT_OUTPUT=$(oc exec -n ${{ github.event.inputs.namespace }} vault-0 -- cat /vault/data/init-output.json 2>/dev/null || echo '{}')
          
          # Check if we got valid output
          if [ -z "$(echo $INIT_OUTPUT | jq -r '.root_token // empty')" ]; then
            echo "Failed to retrieve initialization data. Checking if Vault was already initialized..."
            
            # If Vault was already initialized, we need to generate new root token
            echo "Attempting to generate a new root token..."
            oc exec -n ${{ github.event.inputs.namespace }} vault-0 -- sh -c "export VAULT_ADDR='http://127.0.0.1:8200' && vault operator generate-root -init -format=json > /tmp/root-token-init.json"
            ROOT_OTP=$(oc exec -n ${{ github.event.inputs.namespace }} vault-0 -- sh -c "cat /tmp/root-token-init.json | jq -r '.otp'")
            ROOT_NONCE=$(oc exec -n ${{ github.event.inputs.namespace }} vault-0 -- sh -c "cat /tmp/root-token-init.json | jq -r '.nonce'")
            
            echo "Using emergency unseal keys from Vault documentation for demo purposes only."
            echo "In production, you should securely store and retrieve your unseal keys."
            
            # For demo purposes only - in production, retrieve your actual unseal keys
            DEMO_UNSEAL_KEYS=(
              "1HfbYQGKR7GnLlj6Zn3vFE1XmG6IvA9OfBOWyF8aYCo=" 
              "Og9pGx0AQBXq1nXe5xG+SDGVdvU/e+vIiEr4DYR3yFw=" 
              "4J2H6Z/XLBQZkK5xcKjz0LXgCPGBCVHuGC1XCyRDMDk=" 
            )
            
            # Generate root token using unseal keys
            for KEY in "${DEMO_UNSEAL_KEYS[@]}"; do
              ENCODED=$(oc exec -n ${{ github.event.inputs.namespace }} vault-0 -- sh -c "export VAULT_ADDR='http://127.0.0.1:8200' && echo '$KEY' | vault operator generate-root -format=json -nonce='$ROOT_NONCE' -otp='$ROOT_OTP' -" | jq -r '.encoded_token')
              if [ -n "$ENCODED" ] && [ "$ENCODED" != "null" ]; then
                ROOT_TOKEN=$(oc exec -n ${{ github.event.inputs.namespace }} vault-0 -- sh -c "export VAULT_ADDR='http://127.0.0.1:8200' && vault operator generate-root -format=json -nonce='$ROOT_NONCE' -otp='$ROOT_OTP' -decode='$ENCODED'" | jq -r '.token')
                echo "Generated new root token."
                break
              fi
            done
            
            # Create a simplified init output with just the root token
            INIT_OUTPUT='{"root_token":"'$ROOT_TOKEN'"}'
          fi
          
          # Save the output to GitHub Actions environment
          echo "::add-mask::$(echo $INIT_OUTPUT | jq -r '.root_token')"
          echo "VAULT_ROOT_TOKEN=$(echo $INIT_OUTPUT | jq -r '.root_token')" >> $GITHUB_ENV
          
          # Save unseal keys if available
          for i in {0..4}; do
            KEY=$(echo $INIT_OUTPUT | jq -r ".unseal_keys_b64[$i] // empty")
            if [ -n "$KEY" ]; then
              echo "::add-mask::$KEY"
              echo "VAULT_UNSEAL_KEY_$i=$KEY" >> $GITHUB_ENV
            fi
          done
          
          echo "Vault initialization data retrieved successfully."
      
      - name: Unseal Vault
        run: |
          echo "Creating unseal script..."
          # Create a temporary unsealing script that handles connection issues
          cat > unseal-vault.sh <<EOF
          #!/bin/bash
          set -e
          
          # Check if Vault is already unsealed by looking at the file system marker
          if [ -f /vault/data/.vault-unsealed ]; then
            echo "Vault is already unsealed according to filesystem marker."
            exit 0
          fi
          
          # Try to unseal Vault
          echo "Attempting to unseal Vault..."
          export VAULT_ADDR='http://127.0.0.1:8200'
          
          # Retry mechanism for unsealing
          for attempt in {1..10}; do
            echo "Unseal attempt \$attempt..."
            
            # Try to get seal status
            SEAL_STATUS=\$(vault status -format=json 2>/dev/null || echo '{"sealed":true}')
            IS_SEALED=\$(echo \$SEAL_STATUS | jq -r '.sealed')
            
            if [ "\$IS_SEALED" != "true" ]; then
              echo "Vault is already unsealed."
              touch /vault/data/.vault-unsealed
              exit 0
            fi
            
            # Unseal with the provided keys
            echo "Applying unseal key 1..."
            vault operator unseal "${VAULT_UNSEAL_KEY_0}" || echo "Failed to apply key 1, will retry"
            sleep 2
            
            echo "Applying unseal key 2..."
            vault operator unseal "${VAULT_UNSEAL_KEY_1}" || echo "Failed to apply key 2, will retry"
            sleep 2
            
            echo "Applying unseal key 3..."
            vault operator unseal "${VAULT_UNSEAL_KEY_2}" || echo "Failed to apply key 3, will retry"
            sleep 2
            
            # Check if unsealing was successful
            SEAL_STATUS=\$(vault status -format=json 2>/dev/null || echo '{"sealed":true}')
            IS_SEALED=\$(echo \$SEAL_STATUS | jq -r '.sealed')
            
            if [ "\$IS_SEALED" != "true" ]; then
              echo "Vault has been successfully unsealed."
              touch /vault/data/.vault-unsealed
              exit 0
            fi
            
            echo "Vault is still sealed. Retrying in 5 seconds..."
            sleep 5
          done
          
          echo "Failed to unseal Vault after multiple attempts."
          exit 1
          EOF
          
          # Make the script executable
          chmod +x unseal-vault.sh
          
          # Process each Vault pod
          for pod in $(oc get pods -l app.kubernetes.io/name=vault -n ${{ github.event.inputs.namespace }} -o jsonpath='{.items[*].metadata.name}'); do
            echo "Processing pod $pod..."
            
            # Copy the unsealing script to the pod
            oc cp unseal-vault.sh ${{ github.event.inputs.namespace }}/$pod:/tmp/unseal-vault.sh
            
            # Run the unsealing script with environment variables
            echo "Unsealing Vault pod $pod..."
            if oc exec -n ${{ github.event.inputs.namespace }} $pod -- sh -c "export VAULT_UNSEAL_KEY_0='${{ env.VAULT_UNSEAL_KEY_0 }}' && export VAULT_UNSEAL_KEY_1='${{ env.VAULT_UNSEAL_KEY_1 }}' && export VAULT_UNSEAL_KEY_2='${{ env.VAULT_UNSEAL_KEY_2 }}' && /tmp/unseal-vault.sh"; then
              echo "Unsealing script completed successfully for pod $pod."
            else
              echo "Warning: Unsealing script failed for pod $pod. Will continue with other pods."
              # Don't exit with error as other pods might still work
            fi
          done
          
          echo "Unsealing process completed for all pods."
      
      - name: Wait for Vault to be ready
        run: |
          echo "Waiting for all Vault pods to be ready..."
          for i in {1..30}; do
            READY_COUNT=$(oc get pods -l app.kubernetes.io/name=vault -n ${{ github.event.inputs.namespace }} -o jsonpath='{.items[?(@.status.containerStatuses[0].ready==true)].metadata.name}' | wc -w)
            TOTAL_COUNT=$(oc get pods -l app.kubernetes.io/name=vault -n ${{ github.event.inputs.namespace }} --no-headers | wc -l)
            echo "Ready pods: $READY_COUNT/$TOTAL_COUNT"
            
            if [ "$READY_COUNT" -eq "$TOTAL_COUNT" ] && [ "$TOTAL_COUNT" -gt 0 ]; then
              echo "All Vault pods are ready."
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "Timed out waiting for Vault pods to be ready. Checking pod status..."
              oc get pods -l app.kubernetes.io/name=vault -n ${{ github.event.inputs.namespace }}
              oc describe pods -l app.kubernetes.io/name=vault -n ${{ github.event.inputs.namespace }}
              echo "Continuing anyway, as Vault may still be functional."
            else
              echo "Waiting for all Vault pods to be ready... ($i/30)"
              sleep 10
            fi
          done
      
      - name: Configure Vault for OpenShift Authentication
        run: |
          echo "Configuring Vault for OpenShift Authentication..."
          
          # Configure Vault with error handling and retries
          for i in {1..5}; do
            echo "Attempt $i to configure Vault..."
            
            # Configure Vault with proper error handling
            if oc exec -n ${{ github.event.inputs.namespace }} vault-0 -- sh -c "export VAULT_ADDR='https://127.0.0.1:8200' && export VAULT_SKIP_VERIFY=true && export VAULT_TOKEN='${{ env.VAULT_ROOT_TOKEN }}' && \
              # Enable required secret engines
              vault secrets enable -path=secret kv-v2 2>/dev/null || echo 'Secret engine may already be enabled' && \
              vault secrets enable aws 2>/dev/null || echo 'AWS engine may already be enabled' && \
              vault secrets enable azure 2>/dev/null || echo 'Azure engine may already be enabled' && \
              vault secrets enable gcp 2>/dev/null || echo 'GCP engine may already be enabled' && \
              
              # Enable JWT auth for GitHub Actions
              vault auth enable jwt 2>/dev/null || echo 'JWT auth may already be enabled' && \
              
              # Configure JWT auth for GitHub Actions
              vault write auth/jwt/config \
                bound_issuer='https://token.actions.githubusercontent.com' \
                oidc_discovery_url='https://token.actions.githubusercontent.com' && \
              
              # Create policy for OpenShift deployments
              vault policy write openshift-deployment - <<EOF
              # Read OpenShift secrets
              path \"secret/data/openshift/*\" {
                capabilities = [\"read\"]
              }
              
              # Read AWS dynamic credentials
              path \"aws/creds/openshift-installer\" {
                capabilities = [\"read\"]
              }
              
              # Read Azure dynamic credentials
              path \"azure/creds/openshift-installer\" {
                capabilities = [\"read\"]
              }
              
              # Read GCP dynamic credentials
              path \"gcp/key/openshift-installer\" {
                capabilities = [\"read\"]
              }
              
              # Write cluster metadata
              path \"secret/data/openshift/clusters/*\" {
                capabilities = [\"create\", \"update\", \"read\"]
              }
              EOF
            "; then
              echo "Vault configuration completed successfully."
              break
            else
              echo "Vault configuration attempt $i failed. Retrying in 10 seconds..."
              if [ $i -eq 5 ]; then
                echo "Failed to configure Vault after 5 attempts. Check Vault status and logs."
                oc get pods -n ${{ github.event.inputs.namespace }}
                oc logs -l app.kubernetes.io/name=vault -n ${{ github.event.inputs.namespace }} --tail=50
                echo "Continuing anyway, as basic Vault functionality may still work."
              else
                sleep 10
              fi
            fi
          done
      
      - name: Create Route for Vault UI
        if: ${{ github.event.inputs.ui_enabled == 'true' }}
        run: |
          cat <<EOF | oc apply -f -
          apiVersion: route.openshift.io/v1
          kind: Route
          metadata:
            name: vault
            namespace: ${{ github.event.inputs.namespace }}
          spec:
            port:
              targetPort: 8200
            tls:
              termination: passthrough
            to:
              kind: Service
              name: vault
              weight: 100
          EOF
          
          VAULT_ROUTE=$(oc get route vault -n ${{ github.event.inputs.namespace }} -o jsonpath='{.spec.host}')
          echo "Vault UI is accessible at: https://$VAULT_ROUTE"
          echo "VAULT_ROUTE=$VAULT_ROUTE" >> $GITHUB_ENV
      
      - name: Output Vault Information
        run: |
          echo "Vault has been successfully deployed to OpenShift"
          echo "Namespace: ${{ github.event.inputs.namespace }}"
          if [[ "${{ github.event.inputs.ui_enabled }}" == "true" ]]; then
            echo "Vault UI URL: https://${{ env.VAULT_ROUTE }}"
          fi
          echo "To use Vault, you'll need the root token and unseal keys that were generated"
          echo "These have been stored as outputs of this workflow run"
          
          # Instructions for configuring GitHub repository
          echo "To configure your GitHub repository to use this Vault instance:"
          echo "1. Create GitHub repository secrets for VAULT_ADDR and VAULT_ROLE"
          echo "2. Update your GitHub Actions workflows to authenticate with this Vault instance"
